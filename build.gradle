buildscript {
   repositories {
      mavenCentral()
      jcenter()
   }
   dependencies {
      classpath platform('com.amazonaws:aws-java-sdk-bom:1.11.+')
      classpath 'com.amazonaws:aws-java-sdk-s3'
      classpath group: 'com.fasterxml.jackson.dataformat', name: 'jackson-dataformat-yaml', version: '2.12.1'
      classpath group: 'com.fasterxml.jackson.core', name: 'jackson-databind', version: '2.12.1'
      classpath group: 'org.apache.commons', name: 'commons-lang3', version: '3.12.0'
      classpath group: 'org.seleniumhq.selenium', name: 'selenium-java', version: '3.141.59'
      classpath group: 'org.seleniumhq.selenium', name: 'selenium-chrome-driver', version: '3.141.59'
   }
}

plugins {
    id 'org.barfuin.gradle.taskinfo' version '1.0.5'
    id 'org.gradle.crypto.checksum' version '1.1.0'
}

apply plugin:'base'

group 'aws.eventengine.templates'
version '1.0-SNAPSHOT'

import com.fasterxml.jackson.databind.ObjectMapper
import com.fasterxml.jackson.dataformat.yaml.YAMLFactory
import com.fasterxml.jackson.core.type.TypeReference
import java.util.HashMap
import org.apache.tools.ant.filters.ReplaceTokens
import org.gradle.crypto.checksum.Checksum
import java.io.FileInputStream
import java.io.IOException
import java.io.File
import java.security.DigestInputStream
import java.security.MessageDigest
import java.security.NoSuchAlgorithmException
import java.nio.file.Path
import java.nio.file.Paths
import java.nio.file.Files
import java.io.IOException
import java.nio.file.StandardOpenOption
import org.openqa.selenium.chrome.ChromeOptions
import org.openqa.selenium.WebDriver
import org.openqa.selenium.WebElement
import org.openqa.selenium.support.ui.WebDriverWait
import org.openqa.selenium.support.ui.ExpectedConditions
import org.openqa.selenium.By
import org.openqa.selenium.NoSuchElementException
import org.openqa.selenium.chrome.ChromeDriver
import org.gradle.api.tasks.TaskAction
import org.gradle.api.DefaultTask
import java.awt.Toolkit
import java.awt.datatransfer.Clipboard
import java.awt.datatransfer.Transferable
import java.awt.datatransfer.DataFlavor
import org.openqa.selenium.StaleElementReferenceException

ext {
   TRACE_ENABLED = false;
}

def stopBuild(String message) {
   throw new GradleException(message)
}

def trace(String message, String projectName) {
   if(TRACE_ENABLED) {
      println( projectName + " -> " + message)
   }
}

def checksum(String filepath) throws IOException {
  println "Zip file " + filepath
  def MessageDigest md = MessageDigest.getInstance("SHA-256");
  def DigestInputStream dis = null;
  try{
      dis = new DigestInputStream(new FileInputStream(filepath),md)
      while (dis.read() != -1) ; //empty loop to clear the data
         md = dis.getMessageDigest();
  }catch(Exception dexcp) {
   if(dis != null) {
      try {
         dis.close();
      }catch(Exception excp) {}
   }
  }
  def StringBuilder result = new StringBuilder();
  for (byte b : md.digest()) {
      result.append(String.format("%02x", b));
  }
  //println "digest" + result
  md  .reset()
  return result.toString();
}

subprojects {
   apply plugin:'base'
   
   task copyBaseTemplate(type: Copy) {
      trace("Copy base templates",project.name)
      from(rootProject.projectDir.absolutePath + File.separator + "base-templates") {
      }
      into "${buildDir}/libs/templates" 
   }
   
   task copyProjectTemplate(type: Copy) {
      trace("Copy project templates",project.name)
      from(projectDir.absolutePath + File.separator + "templates") {
         //filter(ReplaceTokens, replaceTokens)
      }
      into "${buildDir}/libs/templates"
   }
   
   task readConfig() {
      //this is purely a configuration task and to initialize the builds
      trace("read configuration file",project.name)
      String fileName = "config.yaml" 
      String overrideFileName = project.getProperty("configFileNameOverrides");
      if( overrideFileName != null && !"".equals(overrideFileName.trim())) {
         fileName = projectDir.absolutePath + File.separator + overrideFileName
      } else {
         fileName = projectDir.absolutePath + File.separator + fileName
      }
      File file = new File(fileName)
      println "Using configuration for module " + project.name + " file : " + fileName + " exists: " + file.exists()
      if(file.exists()) {
         ObjectMapper mapper = new ObjectMapper(new YAMLFactory())
         TypeReference<HashMap<String,Object>> typeRef = new TypeReference<HashMap<String,Object>>() {};
         def config = mapper.readValue(file,typeRef)
         println project.name + "  " + project.hashCode()
         project.ext.config = config
      }
   }
   
   task copyBaseScripts(type: Copy) {
      trace("Copy base scripts",project.name)
      from(rootProject.projectDir.absolutePath + File.separator + "base-scripts")
      into "${buildDir}/libs/scripts"
   }
   
   task copyProjectScripts(type: Copy) {
      from(projectDir.absolutePath + File.separator + "scripts")
      into "${buildDir}/libs/scripts"
   }
   
   task generateScripts(type: Copy) {
         trace("generate scripts",project.name)
         copyProjectScripts.mustRunAfter(copyBaseScripts)
         dependsOn(copyBaseScripts,copyProjectScripts)
         from("${buildDir}/libs/scripts") {
            if(project.ext.has("config")) {
               HashMap replaceValues = new HashMap();
               for(def scriptValues : project.ext.config.ScriptFiles) {
                  //println scriptValues.value
                  replaceValues.putAll(scriptValues.value)
               }
               filter(ReplaceTokens, tokens: replaceValues)
            }
         }
         into "${buildDir}/libs/final/scripts"
   }
   
   task createExecutorScript() {
      trace("generate scripts",project.name)
      dependsOn(generateScripts)
      doLast {
         //println "Exec --> " + "project.name " + project.name + " " + project.hashCode() + " " + project.ext.config
         if(project.ext.has("config")) {
            Path path = Paths.get("${buildDir}/libs/final/scripts/install.sh");
            Path uninstallPath = Paths.get("${buildDir}/libs/final/scripts/uninstall.sh");
            StringBuilder execScript = new StringBuilder('#!/bin/bash').append(System.lineSeparator());
            execScript.append(System.lineSeparator())
            
            execScript.append("FAILED_SCRIPT=''").append(System.lineSeparator()).append('trap cleanup ERR').append(System.lineSeparator());
            
            execScript.append(System.lineSeparator())
            execScript.append('function cleanup() {').append(System.lineSeparator());
            execScript.append(' if [ ! -z "$FAILED_SCRIPT" ] ; then').append(System.lineSeparator());
            execScript.append(' source ./cleanup.sh').append(System.lineSeparator());
            execScript.append(' cleanup_$FAILED_SCRIPT').append(System.lineSeparator());
            execScript.append(' fi').append(System.lineSeparator()).append('}');
            execScript.append(System.lineSeparator())
            
            execScript.append(System.lineSeparator())
            execScript.append('source .').append(File.separator).append('init.sh >> /tmp/scriptLogs.txt')
            execScript.append(System.lineSeparator())
            
            for(def scriptValues : project.ext.config.ScriptFiles) {
               execScript.append(System.lineSeparator())
               execScript.append('grep ').append('\'' + scriptValues.key + '\'').append(' ')
               execScript.append('/tmp/lastExecutedScript.txt').append(System.lineSeparator())
               execScript.append('CMDEXEC=$?').append(System.lineSeparator);
               execScript.append('if [ $CMDEXEC -ne 0 ]; then').append(System.lineSeparator())
               execScript.append("FAILED_SCRIPT='").append(scriptValues.key).append("'").append(System.lineSeparator())
               execScript.append('set -ex').append(System.lineSeparator())
               execScript.append('source .').append(File.separator).append(scriptValues.key).append(' >> /tmp/scriptLogs.txt');
               execScript.append(System.lineSeparator()).append('set +ex')
               execScript.append(System.lineSeparator()).append('fi').append(System.lineSeparator())
               execScript.append('echo `date` ').append('\'' + scriptValues.key + '\'').append(' >> /tmp/lastExecutedScript.txt')
               execScript.append(System.lineSeparator()).append("FAILED_SCRIPT=''").append(System.lineSeparator())
            }
            path.getParent().toFile().mkdirs()
            if(!path.toFile().exists()) {
               Files.createFile(path)
            }
            println "Uninstall path "  + uninstallPath.toFile().exists()
            if(!uninstallPath.toFile().exists()) {
               Files.createFile(uninstallPath)
            }
            Files.write(path, execScript.toString().getBytes());
         }
      }
   }
   
   task zipScripts(type: Zip) {
      dependsOn(createExecutorScript)
      if(project.ext.has("config")) {
         from("${buildDir}/libs/final/scripts")
         include '*'
         archiveName 'install.zip'
         destinationDir(file("${buildDir}/libs/final/module"))
      }
   }
   
   task generateTemplates(type: Copy) {
      trace("generate templates",project.name)
      copyBaseTemplate.mustRunAfter(zipScripts)
      copyProjectTemplate.mustRunAfter(copyBaseTemplate)
      dependsOn(copyBaseTemplate,copyProjectTemplate,zipScripts)

      from("${buildDir}/libs/templates/")
      if(project.ext.has("config")) {
         filter(ReplaceTokens, tokens: project.ext.config.TemplateReplace)
      }
      filter { line -> 
         if(project.ext.has("config")) {
            if(line.contains("@InstallModuleSha@")) {
               def checksum = checksum("${buildDir}/libs/final/module/install.zip")
               line = line.replace("@InstallModuleSha@", checksum)
            }
            return line
         }
      }
      into "${buildDir}/libs/final/module"
   }
   
   task initTest() {
      doFirst {
         def command = null
         def proc = null
         if(project.ext.has("config") && project.ext.config.TestConfiguration != null) {
            String shellSpec = project.rootDir.absolutePath + File.separator + "shellspec"
            println 'Location of shellSpec ' + shellSpec
            if(!file(shellSpec).exists()) {
               command = "curl -fsSL https://git.io/shellspec -o " + shellSpec
               println 'Running command ' + command
               proc = command.execute()
               proc.waitFor()
               command = "chmod +x " + shellSpec
               println 'Running command ' + command
               proc = command.execute()
               proc.waitFor()
               command = shellSpec + " -y"
               println 'Running command ' + command
               proc = command.execute()
               proc.waitFor()
            }
         }
      }
   }
   
   task generateTests() {
      //dependsOn(initTest)
      doFirst {
         def command = null
         def proc = null
         if(project.ext.has("config") && project.ext.config.TestConfiguration != null) {
            String workshopUrl = project.ext.config.TestConfiguration.WorkshopRemoteUrl
            boolean testRemote =  project.ext.config.TestConfiguration.TestRemote
            if(!testRemote) {
               workshopUrl = "http://localhost:8080"
            }
            println 'Using workshop url ' + workshopUrl
            WorkshopCodeExtractor wrshpPage = new WorkshopCodeExtractor(
            "//nav[@aria-hidden='false']//div[contains(@class,'awsui_expandable-link-group')]",
            "//a",
            "//main//code[@class='language-bash' or @class='sh']/../..//button[@data-testid='copy-button']  |  //main",
            "//main//div[@role='button' and @aria-expanded='false'] | //main//div[@role='button' and @aria-expanded='true'] | //main",
            "//button[@data-testid='preview-component-next-btn' or @data-testid='component-next-btn']",
            workshopUrl
            )
            try {
               wrshpPage.initDriver().scrapeCode()
            } finally {
               //TBD: Cleanup finally 
               wrshpPage.close()
            }
         }
      }
   }
}

class WorkshopCodeExtractor implements AutoCloseable{
   
   private final String navLinksPath
   private final String navLinksPathExpander
   private final String navLinkTopic
   private final String codeCopyButton
   private final String workshopUrl
   private final String nextBttn
   private final String subPageLinks
   private final Map<String, List<String>> codeToTopicMapping
   
   private WebDriver driver
   
   /**
    * Initiatize with navigation and 
    */
   public WorkshopCodeExtractor(String navLinksPath, String navLinkTopic, String codeCopyButton, String subPageLinks, String nextBttn, String workshopUrl) {
      this.navLinksPath = navLinksPath
      this.navLinkTopic = navLinkTopic
      this.codeCopyButton = codeCopyButton
      this.workshopUrl = workshopUrl
      this.subPageLinks = subPageLinks
      this.codeToTopicMapping = new HashMap<String, List<String>>()
      this.nextBttn = nextBttn
   }
   
   /**
    * Initiaize Driver
    */
   public WorkshopCodeExtractor initDriver() {
      println "Initialization start...."
      ChromeOptions options = new ChromeOptions()
      options.addArguments("--headless");
      driver = new ChromeDriver(options)
      driver.manage().window().maximize()
      driver.get(workshopUrl)
      println "Initialization complete..."
      return this
   }
   
   public WorkshopCodeExtractor scrapeCode() {
      println "Scrape code start..."
      WebDriverWait wait = new WebDriverWait(driver, 5)
      List<WebElement> navLinks = wait.until(
             ExpectedConditions.visibilityOfAllElementsLocatedBy(By.xpath(navLinksPath)))
      int count = 1
      for(WebElement navLink : navLinks) {
         String xpath = "(" + navLinksPath + ")[" + count + "]" + navLinkTopic
         //println "Looking for xpath " + xpath
         List<WebElement> navLinkTopics = wait.until(ExpectedConditions.presenceOfAllElementsLocatedBy(By.xpath(xpath)))
         //println "Nav Links Topics " + navLinkTopics.size()
         for(WebElement navLinkTopic : navLinkTopics) {
	    wait.until(ExpectedConditions.visibilityOf(navLinkTopic))
	    navLinkTopic.click();
            wait.until(ExpectedConditions.visibilityOfElementLocated(By.xpath(nextBttn)))
            String topicText = navLinkTopic.getText()
	    println topicText
            try {
                List<WebElement> subPageLinksBtns = wait.until(ExpectedConditions.presenceOfAllElementsLocatedBy(By.xpath(subPageLinks)))
                for(int subPgCnt = 1; subPgCnt < subPageLinksBtns.size(); subPgCnt++) {
                   WebElement btn = wait.until(ExpectedConditions.visibilityOfElementLocated(By.xpath("(" + subPageLinks + ")[" + (subPgCnt + 1) + "]" )))
                   try {
                     if("false".equals(btn.getAttribute("aria-expanded"))) {
                       btn.click()
		     }
                    }catch(StaleElementReferenceException sexcp) {
                      println "Element refreshed..."
                      btn = wait.until(ExpectedConditions.visibilityOfElementLocated(By.xpath("(" + subPageLinks + ")[" + (subPgCnt + 1) + "]" )))
                      if("false".equals(btn.getAttribute("aria-expanded"))) {
                        btn.click()
		      }
                   }

                }
            	List<WebElement> codeButtons = wait.until(ExpectedConditions.presenceOfAllElementsLocatedBy(By.xpath(codeCopyButton)))
                println "Topic " + topicText + " has " + codeButtons.size() + " code blocks "
                for(int codeCnt = 1; codeCnt < codeButtons.size(); codeCnt++) {
		   WebElement btn = wait.until(ExpectedConditions.visibilityOfElementLocated(By.xpath("(" + codeCopyButton + ")[" + (codeCnt + 1) + "]" )))
                   try {
		      btn.click()
	           } catch(StaleElementReferenceException sexcp) {
                      println "Element refreshed..."
                      btn = wait.until(ExpectedConditions.visibilityOfElementLocated(By.xpath("(" + codeCopyButton + ")[" + (codeCnt + 1) + "]" )))
                      btn.click()
		   }
		   Clipboard clipboard = Toolkit.getDefaultToolkit().getSystemClipboard()
                   Transferable contents = clipboard.getContents(null)
                   String codeContent =  (String) contents.getTransferData(DataFlavor.stringFlavor) 
                   println codeContent                  	
		}
	    }catch(NoSuchElementException nexcp) {
	       println "No code blocks found in topic " + topicText + "..."
	    }
         }
         count++;
      }
      println "Scrape code complete..."
      return this;
   }
 
   public void close() {
      /*
       try{
          Thread.sleep(8000);
      }catch(Exception excp) {}
      */
      driver.quit();
   }
}

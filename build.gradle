buildscript {
   repositories {
      mavenCentral()
      jcenter()
   }
   dependencies {
      classpath platform('com.amazonaws:aws-java-sdk-bom:1.11.+')
      classpath 'com.amazonaws:aws-java-sdk-s3'
      classpath group: 'com.fasterxml.jackson.dataformat', name: 'jackson-dataformat-yaml', version: '2.12.1'
      classpath group: 'com.fasterxml.jackson.core', name: 'jackson-databind', version: '2.12.1'
      classpath group: 'org.apache.commons', name: 'commons-lang3', version: '3.12.0'
      classpath group: 'org.seleniumhq.selenium', name: 'selenium-java', version: '3.141.59'
      classpath group: 'org.seleniumhq.selenium', name: 'selenium-chrome-driver', version: '3.141.59'
      classpath group: 'org.commonmark', name: 'commonmark', version: '0.18.1'
      classpath group: 'com.vladsch.flexmark', name: 'flexmark-all', version: '0.62.2'

   }
}

plugins {
    id 'org.barfuin.gradle.taskinfo' version '1.0.5'
    id 'org.gradle.crypto.checksum' version '1.1.0'
}

apply plugin:'base'

group 'aws.eventengine.templates'
version '1.0-SNAPSHOT'

import com.fasterxml.jackson.databind.ObjectMapper
import com.fasterxml.jackson.dataformat.yaml.YAMLFactory
import com.fasterxml.jackson.core.type.TypeReference
import java.util.HashMap
import java.util.TreeMap
import org.apache.tools.ant.filters.ReplaceTokens
import org.gradle.crypto.checksum.Checksum
import java.io.FileInputStream
import java.io.IOException
import java.io.File
import java.security.DigestInputStream
import java.security.MessageDigest
import java.security.NoSuchAlgorithmException
import java.nio.file.Path
import java.nio.file.Paths
import java.nio.file.Files
import java.io.IOException
import java.util.StringBuilder
import java.nio.file.StandardOpenOption
import org.openqa.selenium.chrome.ChromeOptions
import org.openqa.selenium.WebDriver
import org.openqa.selenium.WebElement
import org.openqa.selenium.support.ui.WebDriverWait
import org.openqa.selenium.support.ui.ExpectedConditions
import org.openqa.selenium.By
import org.openqa.selenium.NoSuchElementException
import org.openqa.selenium.chrome.ChromeDriver
import org.gradle.api.tasks.TaskAction
import org.gradle.api.DefaultTask
import java.awt.Toolkit
import java.awt.datatransfer.Clipboard
import java.awt.datatransfer.Transferable
import java.awt.datatransfer.DataFlavor
import org.openqa.selenium.StaleElementReferenceException
import org.commonmark.node.*
import org.commonmark.parser.Parser
import java.nio.file.Files
import java.nio.file.Path
import java.nio.file.Paths
import java.io.File
import java.io.FileReader
import java.util.stream.Collectors
import java.util.LinkedHashMap

import com.vladsch.flexmark.util.ast.Node
import com.vladsch.flexmark.parser.Parser
import com.vladsch.flexmark.util.data.MutableDataSet
import com.vladsch.flexmark.ext.anchorlink.AnchorLinkExtension
import com.vladsch.flexmark.ext.aside.AsideExtension
import com.vladsch.flexmark.ext.attributes.AttributesExtension
import com.vladsch.flexmark.ext.autolink.AutolinkExtension
import com.vladsch.flexmark.ext.definition.DefinitionExtension
import com.vladsch.flexmark.ext.gfm.issues.GfmIssuesExtension
import com.vladsch.flexmark.ext.gfm.strikethrough.StrikethroughExtension
import com.vladsch.flexmark.ext.gfm.strikethrough.StrikethroughSubscriptExtension
import com.vladsch.flexmark.ext.gfm.tasklist.TaskListExtension
import com.vladsch.flexmark.ext.gfm.users.GfmUsersExtension
import com.vladsch.flexmark.ext.gitlab.GitLabExtension
import com.vladsch.flexmark.ext.yaml.front.matter.YamlFrontMatterExtension
import com.vladsch.flexmark.ast.Text
import com.vladsch.flexmark.util.ast.NodeVisitor
import com.vladsch.flexmark.util.ast.VisitHandler
import com.vladsch.flexmark.ast.FencedCodeBlock
import com.vladsch.flexmark.ast.Heading
import com.vladsch.flexmark.ext.yaml.front.matter.YamlFrontMatterNode
import com.vladsch.flexmark.ast.IndentedCodeBlock
import com.vladsch.flexmark.ast.Code



ext {
   TRACE_ENABLED = false;
}

def stopBuild(String message) {
   throw new GradleException(message)
}

def trace(String message, String projectName) {
   if(TRACE_ENABLED) {
      println( projectName + " -> " + message)
   }
}

def checksum(String filepath) throws IOException {
  println "Zip file " + filepath
  def MessageDigest md = MessageDigest.getInstance("SHA-256");
  def DigestInputStream dis = null;
  try{
      dis = new DigestInputStream(new FileInputStream(filepath),md)
      while (dis.read() != -1) ; //empty loop to clear the data
         md = dis.getMessageDigest();
  }catch(Exception dexcp) {
   if(dis != null) {
      try {
         dis.close();
      }catch(Exception excp) {}
   }
  }
  def StringBuilder result = new StringBuilder();
  for (byte b : md.digest()) {
      result.append(String.format("%02x", b));
  }
  //println "digest" + result
  md  .reset()
  return result.toString();
}

subprojects {
   apply plugin:'base'
   
   task copyBaseTemplate(type: Copy) {
      trace("Copy base templates",project.name)
      from(rootProject.projectDir.absolutePath + File.separator + "base-templates") {
      }
      into "${buildDir}/libs/templates" 
   }
   
   task copyProjectTemplate(type: Copy) {
      trace("Copy project templates",project.name)
      from(projectDir.absolutePath + File.separator + "templates") {
         //filter(ReplaceTokens, replaceTokens)
      }
      into "${buildDir}/libs/templates"
   }
   
   task readConfig() {
      //this is purely a configuration task and to initialize the builds
      trace("read configuration file",project.name)
      String fileName = "config.yaml" 
      String overrideFileName = project.getProperty("configFileNameOverrides");
      if( overrideFileName != null && !"".equals(overrideFileName.trim())) {
         fileName = projectDir.absolutePath + File.separator + overrideFileName
      } else {
         fileName = projectDir.absolutePath + File.separator + fileName
      }
      File file = new File(fileName)
      println "Using configuration for module " + project.name + " file : " + fileName + " exists: " + file.exists()
      if(file.exists()) {
         ObjectMapper mapper = new ObjectMapper(new YAMLFactory())
         TypeReference<HashMap<String,Object>> typeRef = new TypeReference<HashMap<String,Object>>() {};
         def config = mapper.readValue(file,typeRef)
         println project.name + "  " + project.hashCode()
         project.ext.config = config
      }
   }
   
   task copyBaseScripts(type: Copy) {
      trace("Copy base scripts",project.name)
      from(rootProject.projectDir.absolutePath + File.separator + "base-scripts")
      into "${buildDir}/libs/scripts"
   }
   
   task copyProjectScripts(type: Copy) {
      from(projectDir.absolutePath + File.separator + "scripts")
      into "${buildDir}/libs/scripts"
   }
   
   task generateScripts(type: Copy) {
         trace("generate scripts",project.name)
         copyProjectScripts.mustRunAfter(copyBaseScripts)
         dependsOn(copyBaseScripts,copyProjectScripts)
         from("${buildDir}/libs/scripts") {
            if(project.ext.has("config")) {
               HashMap replaceValues = new HashMap();
               for(def scriptValues : project.ext.config.ScriptFiles) {
                  //println scriptValues.value
                  replaceValues.putAll(scriptValues.value)
               }
               filter(ReplaceTokens, tokens: replaceValues)
            }
         }
         into "${buildDir}/libs/final/scripts"
   }
   
   task createExecutorScript() {
      trace("generate scripts",project.name)
      dependsOn(generateScripts)
      doLast {
         //println "Exec --> " + "project.name " + project.name + " " + project.hashCode() + " " + project.ext.config
         if(project.ext.has("config")) {
            Path path = Paths.get("${buildDir}/libs/final/scripts/install.sh");
            Path uninstallPath = Paths.get("${buildDir}/libs/final/scripts/uninstall.sh");
            StringBuilder execScript = new StringBuilder('#!/bin/bash').append(System.lineSeparator());
            execScript.append(System.lineSeparator())
            
            execScript.append("FAILED_SCRIPT=''").append(System.lineSeparator()).append('trap cleanup ERR').append(System.lineSeparator());
            
            execScript.append(System.lineSeparator())
            execScript.append('function cleanup() {').append(System.lineSeparator());
            execScript.append(' if [ ! -z "$FAILED_SCRIPT" ] ; then').append(System.lineSeparator());
            execScript.append(' source ./cleanup.sh').append(System.lineSeparator());
            execScript.append(' cleanup_$FAILED_SCRIPT').append(System.lineSeparator());
            execScript.append(' fi').append(System.lineSeparator()).append('}');
            execScript.append(System.lineSeparator())
            
            execScript.append(System.lineSeparator())
            execScript.append('source .').append(File.separator).append('init.sh >> /tmp/scriptLogs.txt')
            execScript.append(System.lineSeparator())
            
            for(def scriptValues : project.ext.config.ScriptFiles) {
               execScript.append(System.lineSeparator())
               execScript.append('grep ').append('\'' + scriptValues.key + '\'').append(' ')
               execScript.append('/tmp/lastExecutedScript.txt').append(System.lineSeparator())
               execScript.append('CMDEXEC=$?').append(System.lineSeparator);
               execScript.append('if [ $CMDEXEC -ne 0 ]; then').append(System.lineSeparator())
               execScript.append("FAILED_SCRIPT='").append(scriptValues.key).append("'").append(System.lineSeparator())
               execScript.append('set -ex').append(System.lineSeparator())
               execScript.append('source .').append(File.separator).append(scriptValues.key).append(' >> /tmp/scriptLogs.txt');
               execScript.append(System.lineSeparator()).append('set +ex')
               execScript.append(System.lineSeparator()).append('fi').append(System.lineSeparator())
               execScript.append('echo `date` ').append('\'' + scriptValues.key + '\'').append(' >> /tmp/lastExecutedScript.txt')
               execScript.append(System.lineSeparator()).append("FAILED_SCRIPT=''").append(System.lineSeparator())
            }
            path.getParent().toFile().mkdirs()
            if(!path.toFile().exists()) {
               Files.createFile(path)
            }
            println "Uninstall path "  + uninstallPath.toFile().exists()
            if(!uninstallPath.toFile().exists()) {
               Files.createFile(uninstallPath)
            }
            Files.write(path, execScript.toString().getBytes());
         }
      }
   }
   
   task zipScripts(type: Zip) {
      dependsOn(createExecutorScript)
      if(project.ext.has("config")) {
         from("${buildDir}/libs/final/scripts")
         include '*'
         archiveName 'install.zip'
         destinationDir(file("${buildDir}/libs/final/module"))
      }
   }
   
   task generateTemplates(type: Copy) {
      trace("generate templates",project.name)
      copyBaseTemplate.mustRunAfter(zipScripts)
      copyProjectTemplate.mustRunAfter(copyBaseTemplate)
      dependsOn(copyBaseTemplate,copyProjectTemplate,zipScripts)

      from("${buildDir}/libs/templates/")
      if(project.ext.has("config")) {
         filter(ReplaceTokens, tokens: project.ext.config.TemplateReplace)
      }
      filter { line -> 
         if(project.ext.has("config")) {
            if(line.contains("@InstallModuleSha@")) {
               def checksum = checksum("${buildDir}/libs/final/module/install.zip")
               line = line.replace("@InstallModuleSha@", checksum)
            }
            return line
         }
      }
      into "${buildDir}/libs/final/module"
   }
   
   task initTest() {
      doFirst {
         def command = null
         def proc = null
         if(project.ext.has("config") && project.ext.config.TestConfiguration != null) {
            String shellSpec = project.rootDir.absolutePath + File.separator + "shellspec"
            println 'Location of shellSpec ' + shellSpec
            if(!file(shellSpec).exists()) {
               command = "curl -fsSL https://git.io/shellspec -o " + shellSpec
               println 'Running command ' + command
               proc = command.execute()
               proc.waitFor()
               command = "chmod +x " + shellSpec
               println 'Running command ' + command
               proc = command.execute()
               proc.waitFor()
               command = shellSpec + " -y"
               println 'Running command ' + command
               proc = command.execute()
               proc.waitFor()
            }
         }
      }
   }
   
   task generateTests() {
      //dependsOn(initTest)
      doFirst {
         def command = null
         def proc = null
         if(project.ext.has("config") && project.ext.config.TestConfiguration != null) {
<<<<<<< HEAD
            WorkshopCodeMarkupCodeExtractor codegen = new WorkshopCodeMarkupCodeExtractor(project.ext.config.TestConfiguration.WorkshopGitLocation)
            codegen.initParser().scrapeCode()
=======
            String workshopUrl = project.ext.config.TestConfiguration.WorkshopRemoteUrl
            boolean testRemote =  project.ext.config.TestConfiguration.TestRemote
            if(!testRemote) {
               workshopUrl = "http://localhost:8080"
            }
            println 'Using workshop url ' + workshopUrl
            WorkshopCodeExtractor wrshpPage = new WorkshopCodeExtractor(
            "//nav[@aria-hidden='false']//div[contains(@class,'awsui_expandable-link-group')]",
            "//a",
            "//main//code[@class='language-bash' or @class='sh']/../..//button[@data-testid='copy-button']  |  //main",
            "//main//div[@role='button' and @aria-expanded='false'] | //main//div[@role='button' and @aria-expanded='true'] | //main",
            "//button[@data-testid='preview-component-next-btn' or @data-testid='component-next-btn']",
            workshopUrl
            )
            try {
               wrshpPage.initDriver().scrapeCode()
            }catch(Exception excp) {
               excp.printStackTrace()
               throw excp
            } finally {
               //TBD: Cleanup finally 
               wrshpPage.close()
            }
>>>>>>> a0aade53a36d508579c546e65eda7b35c2f0bf6c
         }
      }
   }
}

class WorkshopCodeMarkupCodeExtractor {

   private enum CodeBlkType {
      SHELL_CODE, VALIDATION_TEXT, OTHER_CODE_BLOCKS
   }
   
   private class CodeBlk {
      private String code
      private CodeBlkType type
   }
   
   private class ModuleInfo {
      private StringBuilder moduleKey
      private Map<String,CodeBlk> codeBloks = new LinkedHashMap<String,CodeBlk>()
   }
   
   private final String workshopRepo
   private final Map<String, ModuleInfo>> moduleMapping

   private List<String> mdFiles   
   private File currFile
   
   
   private NodeVisitor fencedCodeBlkVisitor = new NodeVisitor(new VisitHandler<>(FencedCodeBlock.class, { node -> this.visitFencedBlock(node) }))
   
   private NodeVisitor headingBlkVisitor = new NodeVisitor(new VisitHandler<>(Heading.class, { node -> this.visitHeading(node) }))
   
   private NodeVisitor titleBlkVisitor = new NodeVisitor(new VisitHandler<>(YamlFrontMatterNode.class, { node -> this.visitTitle(node) }))
   
   private NodeVisitor indentedCodeBlkVisitor = new NodeVisitor(new VisitHandler<>(IndentedCodeBlock .class, { node -> this.visitIndentedBlock(node) }))
   
   private NodeVisitor codeBlkVisitor = new NodeVisitor(new VisitHandler<>( Code.class, { node -> this.visitCodeBlock(node) }))
   
   public WorkshopCodeMarkupCodeExtractor(String workshopRepo) {
      this.workshopRepo = workshopRepo
      this.codeToTopicMapping = new HashMap<String, List<String>>()
      this.moduleMapping = new TreeMap<String,StringBuilder>
   }
   
   public WorkshopCodeMarkupCodeExtractor initParser() {
      Files.walk(Paths.get(workshopRepo)).withCloseable { walk -> 
         this.mdFiles = walk
            .filter({ file -> !Files.isDirectory(file) })
            .map( { file -> file.toString() })
            .filter({ file -> file.toLowerCase().endsWith("md") })
            .collect(Collectors.toList())
         //println mdFiles
      }
      return this;
   }
   
   public WorkshopCodeMarkupCodeExtractor scrapeCode() throws Exception{
      MutableDataSet options = new MutableDataSet()
      options.set(Parser.EXTENSIONS, Arrays.asList(
      com.vladsch.flexmark.ext.anchorlink.AnchorLinkExtension.create(),
      com.vladsch.flexmark.ext.aside.AsideExtension.create(),
      com.vladsch.flexmark.ext.attributes.AttributesExtension.create(),
      com.vladsch.flexmark.ext.autolink.AutolinkExtension.create(),
      com.vladsch.flexmark.ext.definition.DefinitionExtension.create(),
      com.vladsch.flexmark.ext.gfm.issues.GfmIssuesExtension.create(),
      com.vladsch.flexmark.ext.gfm.strikethrough.StrikethroughExtension.create(),
      com.vladsch.flexmark.ext.gfm.strikethrough.StrikethroughSubscriptExtension.create(),
      com.vladsch.flexmark.ext.gfm.tasklist.TaskListExtension.create(),
      com.vladsch.flexmark.ext.gfm.users.GfmUsersExtension.create(),
      com.vladsch.flexmark.ext.gitlab.GitLabExtension.create(),
      com.vladsch.flexmark.ext.yaml.front.matter.YamlFrontMatterExtension.create()
      ))
      Parser parser = Parser.builder().build();
      for(String mdFile : mdFiles) {
         Reader reader = null
         try {
            File file = new File(mdFile)
            currDir = file.getParentFile().getName()
            currFile = file.getName()
            if(currFile.startsWith("index")) {
               isIndexFile = true
            }
            reader = new FileReader(file)
            Node mdAST = parser.parseReader(reader)
            titleBlkVisitor.visit(mdAST)
            headingBlkVisitor.visit(mdAST)
            fencedCodeBlkVisitor.visit(mdAST)
            indentedCodeBlkVisitor.visit(mdAST)
            codeBlkVisitor.visit(mdAST)
         }finally {
            if(reader != null) {
               reader.close()
            }
         }
      }
   }
   
   public void visitCodeBlock(Code node) {
      println "----------CBL--------------"
      println "GC +=>" + node.getChars()
      println "----------CBL--------------"
      indentedCodeBlkVisitor.visitChildren(node);
   }
   
   
   public void visitIndentedBlock(IndentedCodeBlock node) {
      println "----------INBL--------------"
      println "Content Chars ==>" + node.getContentChars().toString()
      println "Content Lines ==>" + node.getContentLines().toString()
      println "GC +=>" + node.getChars()
      println "----------INBL--------------"
      indentedCodeBlkVisitor.visitChildren(node);
   }
   
<<<<<<< HEAD
   public void visitFencedBlock(FencedCodeBlock node) {
      println "----------FCBL--------------"
      println "Info -->" + node.getInfo() 
      println "Content Chars ==>" + node.getContentChars().toString()
      println "Content Lines ==>" + node.getContentLines().toString()
      println "GC +=>" + node.getChars()
      println "----------FCBL--------------"
      fencedCodeBlkVisitor.visitChildren(node);
    }
    
    public void visitHeading(Heading node) {
      println "----------HBL--------------"
      String title = null, weight = null;
      int indexOfTitle = content.indexOf("title: ")
      int indexOfWeight = content.indexOf("weight: ")
      if(indexOfTitle > -1) {
         int end = content.indexOf("\n",indexOfTitle);
         end = end < 0 ? content.length() : end
         title = content.substring(indexOfTitle + "title: ".length(), end).trim()
      } else {
         title = node.getContentChars()
      }
      if(indexOfWeight > -1) {
         int end = content.indexOf("\n",indexOfWeight);
         end = end < 0 ? content.length() : end
         weight = content.substring(indexOfWeight + "weight: ".length(), end).trim()
      } else {
         weight = "0000"
      }
      generateModuleKey(
      println "Title " + title + " Weight " + weight
      println "----------HBL--------------"
      headingBlkVisitor.visitChildren(node);
    }
   
    public String generateModuleKey(File file, String weight) {
      StringBuilder moduleKey = new StringBuilder("/");
      String parentFileName = file.toParentFile().getName()
      String parentFilePath = file.toParentFile().getPath().replace("\\",File.separator)
      if(weight == null || weight == "") {
         weight = "0000"
      }
      if(weight.length == 3) {
         weight = "0" + weight
      } else if(weight.length == 2) {
         weight = "00" + weight
      } else if(weight.length == 1) {
         weight = "000" + weight
      }
      
      if(!"content".equals(parentFileName) && parentFilePath.startsWith("content" + File.separator)) {
         String parentPathFromContent = parentPath.substring(parentPath.indexOf("content") + File.separator)
         if(!file.getName().startsWith("index")) {
            moduleKey.append("/NA_").append(parentPathFromContent).append("/").append(weight).append("_").append(file.getName())   
         } else {
            moduleKey.append("/").append(weight).append(parentPathFromContent).append("/").append("0000_").append(file.getName())
         }
      } else {
         moduleKey.append(weight).append("_").append(file.getName())
      }
      return moduleKey
    }
